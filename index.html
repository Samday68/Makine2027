<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>VOLATILITY ANALYZER V.1.0</title>
  <link rel="manifest" href="manifest.json">
  <style>
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    
    body { 
      font-family: sans-serif; 
      background: #1a1a1a; 
      color: #fff; 
      margin: 0; 
      padding: 5px; 
      transition: background-color 0.3s, color 0.3s; 
      overflow-x: hidden; 
      overflow-y: auto; 
    }
    
    body.day-mode { 
      background: #fff; 
      color: #000; 
    }
    
    #mainContainer { 
      display: flex; 
      gap: 8px; 
      max-width: 100%; 
      margin: 0 auto; 
    }
    
    #leftSection { 
      flex: 1; 
      min-width: 280px; 
      max-width: 100%; 
    }
    
    #rightSection { 
      flex: 0 0 170px; 
      display: flex; 
      flex-direction: column; 
      gap: 6px; 
      position: relative; 
    }
    
    @media (max-width: 768px) { 
      #mainContainer { gap: 5px; } 
      #leftSection { flex: 1; min-width: 0; } 
      #rightSection { flex: 0 0 140px; } 
      body { padding: 3px; } 
    }
    
    #headerSection { 
      text-align: center; 
      margin: 4px 0; 
      width: 100%; 
    }
    
    #headerLogo { 
      width: 100%; 
      height: 65px; 
      display: block; 
      object-fit: contain; 
      object-position: center; 
      margin: 0 auto; 
      transition: opacity 0.3s; 
    }
    
    @media (max-width: 768px) { 
      #headerLogo { height: 52px; } 
    }
    
    #toggleRow { 
      display: flex; 
      gap: 15px; 
      justify-content: center; 
      align-items: center; 
      margin: 4px auto; 
    }
    
    #graphToggle { 
      height: 20px; 
      font-size: 11px; 
      font-weight: 900; 
      padding: 0 10px; 
      cursor: pointer; 
      border: none; 
      border-radius: 5px; 
      background: #d93025; 
      color: #fff; 
    }
    
    #themeToggle { 
      width: 28px; 
      height: 28px; 
      border: none; 
      border-radius: 50%; 
      background: #333; 
      cursor: pointer; 
      font-size: 14px; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      transition: background 0.3s; 
    }
    
    body.day-mode #themeToggle { 
      background: #ffd700; 
    }
    
    @media (max-width: 768px) { 
      #toggleRow { gap: 12px; } 
      #graphToggle { height: 18px; font-size: 10px; padding: 0 8px; } 
      #themeToggle { width: 24px; height: 24px; font-size: 12px; } 
    }
    
    #pairsWrap { 
      width: 100%; 
      margin: 4px 0; 
      display: flex; 
      align-items: center; 
      gap: 4px; 
      flex-wrap: nowrap; 
    }
    
    #pairs { 
      display: flex; 
      gap: 2px; 
      flex-wrap: nowrap; 
      flex: 1; 
    }
    
    .pair-btn { 
      padding: 6px 3px; 
      border: none; 
      border-radius: 5px; 
      background: #555; 
      color: #fff; 
      cursor: pointer; 
      font-size: 8.5px; 
      font-weight: 600; 
      flex: 1; 
      min-width: 45px; 
      transition: background 0.3s, color 0.3s; 
    }
    
    body.day-mode .pair-btn { 
      background: #e0e0e0; 
      color: #000; 
    }
    
    .pair-btn.active { 
      background: #000; 
      color: #fff; 
    }
    
    @media (max-width: 768px) { 
      .pair-btn { padding: 5px 2px; font-size: 7.5px; min-width: 38px; } 
    }
    
    #startStopBtn { 
      padding: 5px 10px; 
      font-size: 10px; 
      font-weight: 900; 
      cursor: pointer; 
      border: 2px solid #4CAF50; 
      border-radius: 15px; 
      background: #4CAF50; 
      color: #fff; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      gap: 3px; 
      white-space: nowrap; 
      flex-shrink: 0; 
    }
    
    #startStopBtn.stopped { 
      background: #d93025; 
      border-color: #d93025; 
    }
    
    @media (max-width: 768px) { 
      #startStopBtn { padding: 4px 8px; font-size: 9px; } 
    }
    
    #topbar { 
      display: flex; 
      gap: 3px; 
      margin: 4px 0; 
      align-items: center; 
      flex-wrap: wrap; 
    }
    
    #time { 
      background: #000; 
      color: #fff; 
      padding: 3px 6px; 
      border-radius: 3px; 
      font-weight: bold; 
      font-size: 9px; 
      white-space: nowrap; 
      height: 21px; 
      display: flex; 
      align-items: center; 
    }
    
    body.day-mode #time { 
      background: #333; 
    }
    
    #connectBtn { 
      background: #d93025; 
      color: #fff; 
      border: none; 
      padding: 3px 8px; 
      border-radius: 3px; 
      cursor: pointer; 
      font-weight: bold; 
      font-size: 9px; 
      white-space: nowrap; 
      height: 21px; 
      display: flex; 
      align-items: center; 
    }
    
    #apiInput { 
      flex: 1; 
      min-width: 80px; 
      background: #0b57d0; 
      color: #fff; 
      border: none; 
      padding: 3px 6px; 
      border-radius: 3px; 
      font-size: 9px; 
      height: 21px; 
    }
    
    #apiInput::placeholder { 
      color: #cce5ff; 
    }
    
    #saveGroup { 
      display: flex; 
      align-items: center; 
      gap: 3px; 
      padding: 0px 5px; 
      border-radius: 3px; 
      outline: 2px solid #fff; 
      height: 21px; 
    }
    
    body.day-mode #saveGroup { 
      outline: 2px solid #000; 
    }
    
    #saveCheckbox { 
      width: 13px; 
      height: 13px; 
      cursor: pointer; 
      accent-color: #0b57d0; 
      background: #fff; 
      border: 2px solid #fff; 
      border-radius: 2px; 
      padding: 2px; 
    }
    
    body.day-mode #saveCheckbox { 
      background: #fff; 
      border: 2px solid #000; 
    }
    
    #saveLabel { 
      font-size: 8px; 
      font-weight: bold; 
      cursor: pointer; 
      white-space: nowrap; 
      user-select: none; 
    }
    
    #price { 
      background: #0b57d0; 
      color: #fff; 
      padding: 3px 8px; 
      border-radius: 3px; 
      font-weight: bold; 
      font-size: 10px; 
      text-align: center; 
      white-space: nowrap; 
      height: 21px; 
      display: flex; 
      align-items: center; 
    }
    
    @media (max-width: 768px) { 
      #time, #connectBtn { font-size: 8px; padding: 2px 6px; height: 19px; } 
      #apiInput { font-size: 8px; padding: 2px 5px; min-width: 60px; height: 19px; } 
      #saveGroup { gap: 2px; padding: 0px 4px; height: 19px; } 
      #saveCheckbox { width: 12px; height: 12px; } 
      #saveLabel { font-size: 7px; } 
      #price { font-size: 9px; padding: 2px 6px; height: 19px; } 
    }
    
    #chartContainer { 
      position: relative; 
      width: 100%; 
    }
    
    #chart { 
      width: 100%; 
      height: 180px; 
      position: relative; 
      z-index: 2; 
    }
    
    @media (max-width: 768px) { 
      #chart { height: 130px; } 
    }
    
    #chartWatermark { 
      position: absolute; 
      left: 0; 
      top: 50%; 
      transform: translateY(-50%); 
      width: 100%; 
      height: 65px; 
      opacity: 0.18; 
      pointer-events: none; 
      z-index: 1; 
      object-fit: contain; 
      object-position: center; 
      transition: opacity 0.3s; 
    }
    
    @media (max-width: 768px) { 
      #chartWatermark { height: 52px; } 
    }
    
    #xzRowWrap { 
      width: 100%; 
      position: relative; 
      margin-top: 1px; 
    }
    
    #numbersTop { 
      display: flex; 
      flex-wrap: nowrap; 
      justify-content: flex-end; 
      overflow: hidden; 
      width: 100%; 
      position: relative; 
      padding: 3px 0; 
    }
    
    .num-box { 
      flex: 0 0 36px; 
      height: 22px; 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      margin: 1px; 
      color: #fff; 
      font-size: 12px; 
      font-weight: bold; 
      border-radius: 3px; 
    }
    
    @media (max-width: 768px) { 
      .num-box { flex: 0 0 28px; height: 18px; font-size: 10px; margin: 0.5px; } 
    }
    
    .worm-line { 
      position: absolute; 
      height: 1px; 
      border-top: 2px solid; 
      z-index: 5; 
    }
    
    #gridWrap { 
      width: 100%; 
      position: relative; 
      margin-top: 2px; 
    }
    
    #gridTopRow, #gridBottomRow { 
      display: flex; 
      flex-wrap: nowrap; 
      justify-content: flex-end; 
      width: 100%; 
    }
    
    .grid-cell { 
      flex: 0 0 36px; 
      height: 36px; 
      box-sizing: border-box; 
      background: #1a1a1a; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      font-weight: 900; 
      font-size: 16px; 
      line-height: 1; 
      padding: 0; 
      margin: 0; 
      border: 2px solid #444; 
      transition: background 0.3s, border-color 0.3s; 
    }
    
    body.day-mode .grid-cell { 
      background: #fff; 
      border-color: #000; 
    }
    
    @media (max-width: 768px) { 
      .grid-cell { flex: 0 0 28px; height: 28px; font-size: 13px; border: 1.5px solid #444; } 
      body.day-mode .grid-cell { border: 1.5px solid #000; } 
    }
    
    .grid-top { 
      border-color: #0b57d0; 
    }
    
    .grid-bottom { 
      border-color: #d93025; 
    }
    
    #gridDivider { 
      width: 100%; 
      display: flex; 
      justify-content: flex-end; 
      margin: 0; 
      height: 2px; 
      background: transparent; 
    }
    
    #gridDividerLine { 
      height: 2px; 
      background: #fff; 
      width: 0px; 
      transition: background 0.3s; 
    }
    
    body.day-mode #gridDividerLine { 
      background: #000; 
    }
    
    .start-box { 
      position: absolute; 
      border: 2px solid #fff; 
      pointer-events: none; 
      z-index: 50; 
      box-sizing: border-box; 
      transition: border-color 0.3s; 
    }
    
    body.day-mode .start-box { 
      border-color: #000; 
    }
    
    .start-label { 
      position: absolute; 
      top: -10px; 
      left: 50%; 
      transform: translateX(-50%); 
      background: orange; 
      color: #000; 
      font-size: 8px; 
      font-weight: 900; 
      padding: 0 3px; 
      line-height: 10px; 
      border-radius: 2px; 
      white-space: nowrap; 
    }
    
    #analysisBoxes { 
      width: 100%; 
      margin-top: 2px; 
      position: relative; 
    }
    
    #xyBox { 
      position: relative; 
      width: 100%; 
      height: 340px; 
      border-bottom: 2px solid #444; 
      transition: border-color 0.3s; 
    }
    
    body.day-mode #xyBox { 
      border-bottom-color: #000; 
    }
    
    @media (max-width: 768px) { 
      #xyBox { height: 250px; } 
    }
    
    #xyCanvas { 
      width: 100%; 
      height: 100%; 
      display: block; 
    }
    
    /* G√úNCELLENMƒ∞≈û: Trend A√ßƒ± Panelleri Container - B√úY√úT√úLM√ú≈û */
    #trendAnglesRow { 
      display: flex; 
      flex-direction: row;
      gap: 6px; /* 4px'ten 6px'e artƒ±rƒ±ldƒ± */
      width: 100%; 
      height: 85px; /* 70px'ten 85px'e artƒ±rƒ±ldƒ± */
    }
    
    @media (max-width: 768px) { 
      #trendAnglesRow { 
        height: 65px; /* 55px'ten 65px'e artƒ±rƒ±ldƒ± */
        gap: 4px;
      } 
    }
    
    .trend-angle-box { 
      flex: 1; 
      height: 85px; /* 70px'ten 85px'e artƒ±rƒ±ldƒ± */
      background: #1a1a1a; 
      border: 2px solid #444; 
      border-radius: 8px; /* 6px'ten 8px'e artƒ±rƒ±ldƒ± */
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      justify-content: center; 
      transition: background 0.3s, border-color 0.3s; 
      position: relative; 
    }
    
    body.day-mode .trend-angle-box { 
      background: #f5f5f5; 
      border-color: #ccc; 
    }
    
    @media (max-width: 768px) { 
      .trend-angle-box { 
        height: 65px; /* 55px'ten 65px'e artƒ±rƒ±ldƒ± */
        border-radius: 6px;
      } 
    }
    
    .trend-angle-canvas { 
      width: 100%; 
      height: 100%; 
    }
    
    /* Trend Bell Box - Alt Panel (2. A√ßƒ± Panelinin Altƒ±nda) */
    #trendBellContainer {
      width: 100%;
      height: 85px; /* 70px'ten 85px'e artƒ±rƒ±ldƒ± */
      display: flex;
      justify-content: flex-end;
    }
    
    #trendBellBox { 
      width: 50%;
      height: 85px; /* 70px'ten 85px'e artƒ±rƒ±ldƒ± */
      background: #666; 
      border: 2px solid #444; 
      border-radius: 8px; /* 6px'ten 8px'e artƒ±rƒ±ldƒ± */
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      justify-content: center; 
      gap: 6px; /* 4px'ten 6px'e artƒ±rƒ±ldƒ± */
      transition: background 0.3s, border-color 0.3s; 
    }
    
    #trendBellBox.trend-up { 
      background: #0066ff; 
      border-color: #0044cc; 
    }
    
    #trendBellBox.trend-down { 
      background: #cc0000; 
      border-color: #990000; 
    }
    
    body.day-mode #trendBellBox { 
      background: #e0e0e0; 
      border-color: #ccc; 
    }
    
    body.day-mode #trendBellBox.trend-up { 
      background: #0066ff; 
      border-color: #0044cc; 
    }
    
    body.day-mode #trendBellBox.trend-down { 
      background: #cc0000; 
      border-color: #990000; 
    }
    
    @media (max-width: 768px) { 
      #trendBellContainer, #trendBellBox { 
        height: 65px; /* 55px'ten 65px'e artƒ±rƒ±ldƒ± */
        border-radius: 6px;
      } 
    }
    
    #trendBellIcon { 
      font-size: 24px; 
      filter: drop-shadow(0 2px 3px rgba(0,0,0,0.3)); 
    }
    
    @media (max-width: 768px) { 
      #trendBellIcon { font-size: 20px; } 
    }
    
    #trendLabel { 
      font-size: 10px; 
      font-weight: 900; 
      color: #fff; 
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5); 
    }
    
    @media (max-width: 768box) { 
      #trendLabel { font-size: 9px; } 
    }
    
    /* Trading Panel */
    #tradingPanel { 
      width: 100%; 
      background: #000; 
      border: 2px solid #666; 
      border-radius: 6px; 
      padding: 5px; 
      display: flex; 
      flex-direction: column; 
      gap: 4px; 
    }
    
    body.day-mode #tradingPanel { 
      background: #f5f5f5; 
      border-color: #ccc; 
    }
    
    @media (max-width: 768px) { 
      #tradingPanel { padding: 4px; gap: 3px; border: 1.5px solid #666; } 
      body.day-mode #tradingPanel { border: 1.5px solid #ccc; } 
    }
    
    .panel-header-row { 
      display: flex; 
      justify-content: space-between; 
      align-items: flex-start; 
      width: 100%; 
      position: relative; 
      min-height: 24px; 
    }
    
    .duration-container {
      display: flex;
      flex-direction: column;
      gap: 1px;
      flex: 1;
      min-width: 0;
    }
    
    .panel-label { 
      font-size: 8px; 
      font-weight: bold; 
      white-space: nowrap; 
    }
    
    .panel-value { 
      background: #555; 
      color: #fff; 
      padding: 3px 6px; 
      border-radius: 4px; 
      text-align: center; 
      font-size: 10px; 
      font-weight: bold; 
      border: 1.5px solid #666; 
      min-width: 30px; 
    }
    
    body.day-mode .panel-value { 
      background: #fff; 
      color: #000; 
      border-color: #ccc; 
    }
    
    #autoTradeBtn { 
      position: absolute;
      top: 0;
      right: 0;
      width: 18px; 
      height: 9px; 
      border-radius: 4.5px; 
      border: 1px solid #666; 
      background: linear-gradient(to bottom, #444, #222); 
      color: #fff; 
      font-size: 4px; 
      font-weight: 900; 
      cursor: pointer; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      transition: all 0.3s; 
      padding: 0;
      letter-spacing: 0.5px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.5);
      z-index: 10;
    }
    
    #autoTradeBtn:hover {
      transform: translateY(-0.5px);
      box-shadow: 0 1.5px 3px rgba(0,0,0,0.6);
    }
    
    #autoTradeBtn:active {
      transform: translateY(0);
      box-shadow: 0 0.5px 1px rgba(0,0,0,0.4);
    }
    
    #autoTradeBtn.active { 
      background: linear-gradient(to bottom, #ff3333, #cc0000); 
      border-color: #990000; 
      color: #fff; 
      text-shadow: 0 0.5px 0.5px rgba(0,0,0,0.5);
      animation: autoPulse 1.5s infinite; 
    }
    
    @keyframes autoPulse { 
      0%, 100% { 
        opacity: 1; 
        box-shadow: 0 1px 2px rgba(204, 0, 0, 0.5);
      } 
      50% { 
        opacity: 0.85; 
        box-shadow: 0 1px 4px rgba(204, 0, 0, 0.7);
      } 
    }
    
    body.day-mode #autoTradeBtn { 
      background: linear-gradient(to bottom, #ddd, #bbb); 
      color: #000; 
      border-color: #999; 
      box-shadow: 0 1px 2px rgba(0,0,0,0.2);
    }
    
    body.day-mode #autoTradeBtn.active { 
      background: linear-gradient(to bottom, #ff3333, #cc0000); 
      border-color: #990000; 
      color: #fff; 
    }
    
    .panel-row { 
      display: flex; 
      flex-direction: column; 
      gap: 1px; 
      margin-top: 2px; 
    }
    
    .panel-input { 
      background: #555; 
      color: #fff; 
      padding: 4px; 
      border-radius: 4px; 
      text-align: center; 
      font-size: 10px; 
      font-weight: bold; 
      border: 1.5px solid #666; 
      width: 100%; 
    }
    
    body.day-mode .panel-input { 
      background: #fff; 
      color: #000; 
      border-color: #ccc; 
    }
    
    @media (max-width: 768px) { 
      .panel-label { font-size: 7px; } 
      .panel-value, .panel-input { 
        padding: 3px; 
        font-size: 9px; 
        border: 1px solid #666; 
      } 
      body.day-mode .panel-value, body.day-mode .panel-input { border: 1px solid #ccc; } 
      
      #autoTradeBtn {
        width: 16px;
        height: 8px;
        font-size: 3.5px;
        border-radius: 4px;
        border: 1px solid #666;
      }
      
      .panel-header-row {
        min-height: 22px;
      }
    }
    
    .trade-buttons { 
      display: flex; 
      flex-direction: column; 
      gap: 6px; 
      margin-top: 4px; 
    }
    
    @media (max-width: 768px) { 
      .trade-buttons { gap: 4px; margin-top: 2px; } 
    }
    
    .metal-btn { 
      width: 100%; 
      height: 42px; 
      border-radius: 50%; 
      position: relative; 
      border: none; 
      cursor: pointer; 
      background: radial-gradient(circle at 30% 30%, #ffffff, #bdbdbd 35%, #8f8f8f 55%, #f5f5f5 75%, #9b9b9b 100%); 
      box-shadow: inset 0 2px 5px rgba(255,255,255,.9), inset 0 -5px 8px rgba(0,0,0,.7), 0 8px 15px rgba(0,0,0,.9); 
    }
    
    @media (max-width: 768px) { 
      .metal-btn { height: 32px; box-shadow: inset 0 2px 4px rgba(255,255,255,.9), inset 0 -4px 6px rgba(0,0,0,.7), 0 6px 10px rgba(0,0,0,.9); } 
    }
    
    .metal-btn::before { 
      content: ""; 
      position: absolute; 
      inset: 5px; 
      border-radius: 50%; 
      background: linear-gradient(to bottom, var(--light) 0%, var(--mid) 48%, var(--dark) 100%); 
    }
    
    @media (max-width: 768px) { 
      .metal-btn::before { inset: 4px; } 
    }
    
    .metal-btn::after { 
      content: ""; 
      position: absolute; 
      inset: 7px; 
      border-radius: 50%; 
      background: linear-gradient(to bottom, rgba(255,255,255,.45) 0%, rgba(255,255,255,.35) 35%, rgba(255,255,255,0) 36%); 
      pointer-events: none; 
    }
    
    @media (max-width: 768px) { 
      .metal-btn::after { inset: 5px; } 
    }
    
    .up { 
      --light: #aebcff; 
      --mid: #1e3dff; 
      --dark: #0c1f7a; 
    }
    
    .down { 
      --light: #ffb8b8; 
      --mid: #c61f1f; 
      --dark: #6b0000; 
    }
    
    .metal-btn:active { 
      transform: translateY(2px); 
      box-shadow: inset 0 5px 10px rgba(0,0,0,.8), 0 5px 8px rgba(0,0,0,.8); 
    }
    
    .balance-row { 
      display: flex; 
      justify-content: space-between; 
      align-items: center; 
      margin-top: 2px; 
    }
    
    .balance-label { 
      font-size: 8px; 
      font-weight: bold; 
    }
    
    .balance-value { 
      color: #4CAF50; 
      font-size: 8px; 
      font-weight: bold; 
    }
    
    @media (max-width: 768px) { 
      .balance-row { margin-top: 1px; } 
      .balance-label, .balance-value { font-size: 7px; } 
    }
    
    #tradeChart { 
      width: 100%; 
      height: 85px; 
      background: #1a1a1a; 
      border: 2px solid #666; 
      border-radius: 6px; 
      display: none; 
    }
    
    body.day-mode #tradeChart { 
      background: #f5f5f5; 
      border-color: #ccc; 
    }
    
    @media (max-width: 768px) { 
      #tradeChart { height: 70px; border: 1.5px solid #666; } 
      body.day-mode #tradeChart { border: 1.5px solid #ccc; } 
    }
    
    #tradeCanvas { 
      width: 100%; 
      height: 100%; 
      display: block; 
    }
    
    /* Loading Indicator */
    #loadingIndicator {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #1a1a1a;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 0.3s;
    }
    
    .spinner {
      width: 50px;
      height: 50px;
      border: 5px solid #333;
      border-top: 5px solid #0b57d0;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Performance Optimizations */
    .performance-mode {
      transform: translateZ(0);
      backface-visibility: hidden;
      perspective: 1000px;
    }
    
    /* Hardware Acceleration */
    .hw-accelerate {
      transform: translate3d(0, 0, 0);
    }
  </style>
</head>
<body>
  <!-- Loading Screen -->
  <div id="loadingIndicator">
    <div class="spinner"></div>
  </div>
  
  <div id="mainContainer">
    <div id="leftSection">
      <div id="headerSection">
        <img id="headerLogo" src="https://raw.githubusercontent.com/Samday68/Foto-raflar/refs/heads/main/D354DBAF-3EC7-4B5F-ABC1-8EF876797DAA.jpeg" alt="logo" onerror="this.style.display='none';" />
      </div>
      <div id="toggleRow">
        <button id="graphToggle">XZ</button>
        <button id="themeToggle">üåô</button>
      </div>
      <div id="pairsWrap">
        <div id="pairs">
          <button class="pair-btn active" data-pair="R_100">100</button>
          <button class="pair-btn" data-pair="R_75">75</button>
          <button class="pair-btn" data-pair="R_50">50</button>
          <button class="pair-btn" data-pair="R_25">25</button>
          <button class="pair-btn" data-pair="R_10">10</button>
          <button class="pair-btn" data-pair="RDBEAR">BEAR</button>
          <button class="pair-btn" data-pair="RDBULL">BULL</button>
        </div>
        <button id="startStopBtn">
          <span>‚èª</span>
          <span id="startStopText">START</span>
        </button>
      </div>
      <div id="topbar">
        <div id="time">GMT 00:00:00</div>
        <button id="connectBtn">Connect</button>
        <input type="text" id="apiInput" placeholder="Enter Token_ID:">
        <div id="saveGroup">
          <input type="checkbox" id="saveCheckbox">
          <label id="saveLabel" for="saveCheckbox">Save</label>
        </div>
        <div id="price">0.00</div>
      </div>
      <div id="chartContainer">
        <img id="chartWatermark" src="https://raw.githubusercontent.com/Samday68/Foto-raflar/refs/heads/main/D354DBAF-3EC7-4B5F-ABC1-8EF876797DAA.jpeg" alt="" onerror="this.style.display='none';" />
        <canvas id="chart"></canvas>
      </div>
      <div id="xzRowWrap">
        <div id="numbersTop"></div>
      </div>
      <div id="gridWrap">
        <div id="gridTopRow"></div>
        <div id="gridDivider"><div id="gridDividerLine"></div></div>
        <div id="gridBottomRow"></div>
      </div>
      <div id="analysisBoxes">
        <div id="xyBox">
          <canvas id="xyCanvas"></canvas>
        </div>
      </div>
    </div>
    <div id="rightSection">
      <!-- G√úNCELLENMƒ∞≈û: A√ßƒ± panelleri yan yana -->
      <div id="trendAnglesRow">
        <div class="trend-angle-box">
          <canvas id="trendAngleCanvas1" class="trend-angle-canvas"></canvas>
        </div>
        <div class="trend-angle-box">
          <canvas id="trendAngleCanvas2" class="trend-angle-canvas"></canvas>
        </div>
      </div>
      
      <!-- G√úNCELLENMƒ∞≈û: Sesli trend paneli sadece 2. panelin altƒ±nda -->
      <div id="trendBellContainer">
        <div id="trendBellBox">
          <span id="trendBellIcon">üîî</span>
          <span id="trendLabel">Trend</span>
        </div>
      </div>
      
      <div id="tradingPanel">
        <div class="panel-header-row">
          <div class="duration-container">
            <div class="panel-label">Duration:</div>
            <div class="panel-value">5</div>
          </div>
          <button id="autoTradeBtn">AUTO</button>
        </div>
        <div class="panel-row">
          <div class="panel-label">STAKE:</div>
          <input type="number" class="panel-input" id="stakeInput" value="1" min="0.35" step="0.01">
        </div>
        <div class="trade-buttons">
          <button class="metal-btn up" id="callBtn"></button>
          <button class="metal-btn down" id="putBtn"></button>
        </div>
        <div class="balance-row">
          <span class="balance-label">Balance:</span>
          <span class="balance-value" id="balanceValue">$ 0.00</span>
        </div>
        <div class="balance-row">
          <span class="balance-label">Profit:</span>
          <span class="balance-value" id="profitValue">$ 0.00</span>
        </div>
      </div>
      <div id="tradeChart">
        <canvas id="tradeCanvas"></canvas>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  
  <script>
    // ========== PERFORMANCE OPTIMIZATIONS ==========
    let lastFrameTime = 0;
    const FRAME_INTERVAL = 16;
    
    const workerMessageQueue = [];
    let workerBusy = false;
    
    // ========== GLOBAL DEƒûƒ∞≈ûKENLER ==========
    let audioContext = null;
    let lastTrendSignal = null;
    let currentTrendData = { direction: null, last3: [], colors: [], arrows: [] };
    let trendStartGlobal = null;
    let currentUpDownSignal = null;
    let lastUpDownSignal = null;
    let autoTradeEnabled = false;
    let autoTradeInProgress = false;
    let ws = null;
    let derivWS = null;
    let apiToken = '';
    let isRunning = true;
    let prices = [];
    let digits = [];
    let decimalDigits = [];
    let combinedDigits = [];
    let wormLinesTop = [];
    let numColors = [];
    let currentPair = 'R_100';
    let currentGraph = 'XZ';
    let gridHistory = [];
    let startCooldown = 0;
    let xzTickCounter = 0;
    let startGlobalSpan = null;
    let tradeActive = false;
    let tradeType = '';
    let entrySpot = 0;
    let exitSpot = 0;
    let barrier = 0;
    let tradeData = [];
    let contractId = null;
    let chart = null;
    
    // ========== YENƒ∞ TREND A√áI PANELLERƒ∞ ƒ∞√áƒ∞N DEƒûƒ∞≈ûKENLER ==========
    let trendPanel1Data = { numbers: [], colors: [] };
    let trendPanel2Data = { numbers: [], colors: [] };
    
    // ========== WEB WORKER FOR HEAVY CALCULATIONS ==========
    let computationWorker = null;
    
    function initWebWorker() {
      if (window.Worker) {
        try {
          const workerCode = `
            self.onmessage = function(e) {
              const { type, data } = e.data;
              
              if (type === 'analyzeTrend') {
                const { gridHistory, startGlobalSpan, xzTickCounter } = data;
                
                if (!startGlobalSpan || !gridHistory || gridHistory.length < 6) {
                  self.postMessage({ type: 'trendResult', result: null });
                  return;
                }
                
                const vis = gridHistory.length;
                const firstGlobal = xzTickCounter - vis;
                const startFrom = startGlobalSpan.to - firstGlobal + 1;
                
                if (startFrom < 0 || startFrom >= vis - 2) {
                  self.postMessage({ type: 'trendResult', result: null });
                  return;
                }
                
                const afterStart = [];
                for (let i = startFrom; i < vis; i++) {
                  afterStart.push({
                    v: gridHistory[i].v,
                    row: gridHistory[i].row,
                    color: gridHistory[i].effColor
                  });
                }
                
                if (afterStart.length < 3) {
                  self.postMessage({ type: 'trendResult', result: null });
                  return;
                }
                
                const last3 = afterStart.slice(-3);
                const v1 = last3[0].v, v2 = last3[1].v, v3 = last3[2].v;
                const c1 = last3[0].color, c2 = last3[1].color, c3 = last3[2].color;
                
                let trendDirection = null;
                const compare12 = v2 > v1 ? 'up' : (v2 < v1 ? 'down' : 'flat');
                const compare23 = v3 > v2 ? 'up' : (v3 < v2 ? 'down' : 'flat');
                const compare13 = v3 > v1 ? 'up' : (v3 < v1 ? 'down' : 'flat');
                
                if (compare12 === 'up' && compare23 === 'up' && compare13 === 'up') {
                  trendDirection = 'UP';
                } else if (compare12 === 'down' && compare23 === 'down' && compare13 === 'down') {
                  trendDirection = 'DOWN';
                } else if (compare12 === 'down' && compare23 === 'up') {
                  if (v3 > v1 || v3 >= v2) trendDirection = 'UP';
                } else if (compare12 === 'up' && compare23 === 'down') {
                  if (v3 < v1 || v3 <= v2) trendDirection = 'DOWN';
                } else {
                  const blueCount = [c1, c2, c3].filter(c => c === 'blue').length;
                  const redCount = [c1, c2, c3].filter(c => c === 'red').length;
                  if (blueCount >= 2 && compare13 === 'up') trendDirection = 'UP';
                  else if (redCount >= 2 && compare13 === 'down') trendDirection = 'DOWN';
                }
                
                self.postMessage({ 
                  type: 'trendResult', 
                  result: {
                    direction: trendDirection,
                    last3: [v1, v2, v3],
                    colors: [c1, c2, c3]
                  }
                });
              }
            };
          `;
          
          const blob = new Blob([workerCode], { type: 'application/javascript' });
          const workerURL = URL.createObjectURL(blob);
          computationWorker = new Worker(workerURL);
          
          computationWorker.onmessage = function(e) {
            if (e.data.type === 'trendResult') {
              if (e.data.result) {
                currentTrendData = e.data.result;
                showTrendSignal(e.data.result.direction);
              }
              workerBusy = false;
              processWorkerQueue();
            }
          };
          
          console.log('Web Worker initialized for performance');
        } catch (error) {
          console.log('Web Worker initialization failed, using fallback:', error);
        }
      }
    }
    
    function processWorkerQueue() {
      if (workerBusy || workerMessageQueue.length === 0) return;
      
      const nextTask = workerMessageQueue.shift();
      workerBusy = true;
      
      if (computationWorker) {
        computationWorker.postMessage(nextTask);
      } else {
        setTimeout(() => {
          handleWorkerTask(nextTask);
          workerBusy = false;
          processWorkerQueue();
        }, 0);
      }
    }
    
    function handleWorkerTask(task) {
      if (task.type === 'analyzeTrend') {
        const result = analyzeTrendFallback(task.data);
        if (result) {
          currentTrendData = result;
          showTrendSignal(result.direction);
        }
      }
    }
    
    function analyzeTrendFallback(data) {
      const { gridHistory, startGlobalSpan, xzTickCounter } = data;
      
      if (!startGlobalSpan || !gridHistory || gridHistory.length < 6) return null;
      
      const vis = gridHistory.length;
      const firstGlobal = xzTickCounter - vis;
      const startFrom = startGlobalSpan.to - firstGlobal + 1;
      
      if (startFrom < 0 || startFrom >= vis - 2) return null;
      
      const afterStart = [];
      for (let i = startFrom; i < vis; i++) {
        afterStart.push({
          v: gridHistory[i].v,
          row: gridHistory[i].row,
          color: gridHistory[i].effColor
        });
      }
      
      if (afterStart.length < 3) return null;
      
      const last3 = afterStart.slice(-3);
      const v1 = last3[0].v, v2 = last3[1].v, v3 = last3[2].v;
      const c1 = last3[0].color, c2 = last3[1].color, c3 = last3[2].color;
      
      let trendDirection = null;
      const compare12 = v2 > v1 ? 'up' : (v2 < v1 ? 'down' : 'flat');
      const compare23 = v3 > v2 ? 'up' : (v3 < v2 ? 'down' : 'flat');
      const compare13 = v3 > v1 ? 'up' : (v3 < v1 ? 'down' : 'flat');
      
      if (compare12 === 'up' && compare23 === 'up' && compare13 === 'up') {
        trendDirection = 'UP';
      } else if (compare12 === 'down' && compare23 === 'down' && compare13 === 'down') {
        trendDirection = 'DOWN';
      } else if (compare12 === 'down' && compare23 === 'up') {
        if (v3 > v1 || v3 >= v2) trendDirection = 'UP';
      } else if (compare12 === 'up' && compare23 === 'down') {
        if (v3 < v1 || v3 <= v2) trendDirection = 'DOWN';
      } else {
        const blueCount = [c1, c2, c3].filter(c => c === 'blue').length;
        const redCount = [c1, c2, c3].filter(c => c === 'red').length;
        if (blueCount >= 2 && compare13 === 'up') trendDirection = 'UP';
        else if (redCount >= 2 && compare13 === 'down') trendDirection = 'DOWN';
      }
      
      return {
        direction: trendDirection,
        last3: [v1, v2, v3],
        colors: [c1, c2, c3]
      };
    }
    
    // ========== AUDIO FONKSƒ∞YONLARI ==========
    function initAudio() {
      if (!audioContext) {
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch(e) {
          console.log('Audio init error:', e);
        }
      }
      if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume();
      }
      return audioContext;
    }
    
    function playUpTrendSound() {
      requestAnimationFrame(() => {
        const ctx = initAudio();
        if (!ctx) return;
        const now = ctx.currentTime;
        const notes = [
          {freq: 261.63, start: 0, duration: 0.3},
          {freq: 329.63, start: 0.25, duration: 0.3},
          {freq: 392.00, start: 0.5, duration: 0.3},
          {freq: 523.25, start: 0.75, duration: 0.5}
        ];
        notes.forEach(function(note) {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'sine';
          osc.frequency.value = note.freq;
          const startTime = now + note.start;
          gain.gain.setValueAtTime(0, startTime);
          gain.gain.linearRampToValueAtTime(0.12, startTime + 0.05);
          gain.gain.exponentialRampToValueAtTime(0.01, startTime + note.duration);
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.start(startTime);
          osc.stop(startTime + note.duration);
        });
      });
    }
    
    function playDownTrendSound() {
      requestAnimationFrame(() => {
        const ctx = initAudio();
        if (!ctx) return;
        const now = ctx.currentTime;
        const notes = [
          {freq: 392.00, start: 0, duration: 0.3},
          {freq: 329.63, start: 0.25, duration: 0.3},
          {freq: 261.63, start: 0.5, duration: 0.3},
          {freq: 220.00, start: 0.75, duration: 0.5}
        ];
        notes.forEach(function(note) {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'sine';
          osc.frequency.value = note.freq;
          const startTime = now + note.start;
          gain.gain.setValueAtTime(0, startTime);
          gain.gain.linearRampToValueAtTime(0.12, startTime + 0.05);
          gain.gain.exponentialRampToValueAtTime(0.01, startTime + note.duration);
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.start(startTime);
          osc.stop(startTime + note.duration);
        });
      });
    }
    
    // ========== TREND A√áI PANELLERƒ∞ FONKSƒ∞YONLARI (G√úNCELLENMƒ∞≈û) ==========
    function updateTrendPanelsData() {
      if (!startGlobalSpan || gridHistory.length < 4) {
        trendPanel1Data = { numbers: [], colors: [] };
        trendPanel2Data = { numbers: [], colors: [] };
        return;
      }
      
      const vis = gridHistory.length;
      const firstGlobal = xzTickCounter - vis;
      const startFrom = startGlobalSpan.to - firstGlobal + 1;
      
      // Panel 1: ƒ∞lk kutuyu hemen √ßiz (veriyi alƒ±r almaz)
      const panel1Indices = [];
      if (startFrom - 2 >= 0) panel1Indices.push(startFrom - 2);
      if (startFrom - 1 >= 0) panel1Indices.push(startFrom - 1);
      if (startFrom < vis) panel1Indices.push(startFrom);
      
      trendPanel1Data = {
        numbers: panel1Indices.map(i => gridHistory[i].v),
        colors: panel1Indices.map(i => gridHistory[i].effColor)
      };
      
      // Panel 2: ƒ∞kinci kutu i√ßin daha fazla veri bekliyoruz
      const panel2Indices = [];
      if (startFrom + 1 < vis) panel2Indices.push(startFrom + 1);
      if (startFrom + 2 < vis) panel2Indices.push(startFrom + 2);
      if (startFrom + 3 < vis) panel2Indices.push(startFrom + 3);
      
      trendPanel2Data = {
        numbers: panel2Indices.map(i => gridHistory[i].v),
        colors: panel2Indices.map(i => gridHistory[i].effColor)
      };
    }
    
    function drawTrendPanel(canvasId, panelData) {
      requestAnimationFrame(() => {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;
        
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        const ctx = canvas.getContext('2d');
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, rect.width, rect.height);
        
        const isDark = !document.body.classList.contains('day-mode');
        const width = rect.width;
        const height = rect.height;
        
        if (panelData.numbers.length < 3) return;
        
        const numbers = panelData.numbers;
        const colors = panelData.colors;
        
        // Noktalarƒ±n pozisyonlarƒ±nƒ± belirle - ARALIKLAR A√áIK
        const x1 = width * 0.18;  // Sola daha yakƒ±n
        const x2 = width * 0.5;   // Ortada
        const x3 = width * 0.82;  // Saƒüa daha yakƒ±n
        
        // ƒ∞lk sayƒ± her zaman merkezde
        const y1 = height / 2;
        
        // ƒ∞kinci sayƒ±nƒ±n pozisyonunu belirle (kurallara g√∂re)
        let y2;
        let vzY = null; // VZ √ßizgisi pozisyonu
        
        const n1_color = colors[0];
        const n2_color = colors[1];
        const n1_val = numbers[0];
        const n2_val = numbers[1];
        
        // √úst panel √ßizgisi kurallarƒ± (2. sayƒ± √ºstte)
        if (
          (n1_color === 'red' && n2_color === 'blue') ||
          (n1_color === 'red' && n2_color === 'red' && n2_val < n1_val) ||
          (n1_color === 'blue' && n2_color === 'blue' && n2_val > n1_val)
        ) {
          y2 = height * 0.25; // √úst √ßizgi - fotoƒüraftaki gibi daha a≈üaƒüƒ±da
          vzY = y1 - 12; // ƒ∞lk sayƒ±nƒ±n hemen √ºst√ºne VZ √ßizgisi
        }
        // Alt panel √ßizgisi kurallarƒ± (2. sayƒ± altta)
        else if (
          (n1_color === 'blue' && n2_color === 'red') ||
          (n1_color === 'red' && n2_color === 'red' && n2_val > n1_val) ||
          (n1_color === 'blue' && n2_color === 'blue' && n2_val < n1_val)
        ) {
          y2 = height * 0.75; // Alt √ßizgi - fotoƒüraftaki gibi daha yukarƒ±da
          vzY = y1 + 12; // ƒ∞lk sayƒ±nƒ±n hemen altƒ±na VZ √ßizgisi
        } else {
          // Varsayƒ±lan: aynƒ± renk ve fark 1'den b√ºy√ºkse
          if (n1_color === n2_color) {
            if (n2_val > n1_val) {
              y2 = height * 0.25;
              vzY = y1 - 12;
            } else {
              y2 = height * 0.75;
              vzY = y1 + 12;
            }
          } else {
            // Farklƒ± renkler i√ßin varsayƒ±lan
            y2 = height * 0.25;
            vzY = y1 - 12;
          }
        }
        
        // √ú√ß√ºnc√º sayƒ±nƒ±n pozisyonunu belirle (FOTOƒûRAFTAN ANLA≈ûILAN KURALLARA G√ñRE)
        let y3;
        const n3_val = numbers[2];
        const n3_color = colors[2];
        
        // FOTOƒûRAFTAN KURAL: 3. sayƒ± her zaman 1. ve 2. sayƒ±ya g√∂re konumlanƒ±r
        // Ama daha a√ßƒ±k aralƒ±klarla
        
        // 1. KURAL: 3. Sayƒ± √ºst panel √ßizgisindeki sayƒ±dan b√ºy√ºkse
        if (y2 === height * 0.25 && n3_val > n2_val) {
          // √úst paneldeki sayƒ±yƒ± a≈üaƒüƒ± indir, 3. sayƒ±yƒ± en √ºste koy
          y2 = y2 + 15; // 2. sayƒ±yƒ± biraz a≈üaƒüƒ± indir
          y3 = height * 0.25; // 3. sayƒ± en √ºst panele
        }
        // 2. KURAL: 3. Sayƒ± alt panel √ßizgisindeki sayƒ±dan b√ºy√ºkse
        else if (y2 === height * 0.75 && n3_val > n2_val) {
          // Alt paneldeki sayƒ±yƒ± yukarƒ± kaldƒ±r, 3. sayƒ±yƒ± en alta koy
          y2 = y2 - 15; // 2. sayƒ±yƒ± biraz yukarƒ± kaldƒ±r
          y3 = height * 0.75; // 3. sayƒ± en alt panele
        }
        // 3. KURAL: 3. Sayƒ± √ºst panel √ßizgisinden a≈üaƒüƒ±da bir sayƒ± ise
        else if (y2 === height * 0.25 && n3_val < n2_val) {
          if (n3_val >= n1_val) {
            // 3. sayƒ± 1. sayƒ±dan k√º√ß√ºk deƒüilse
            // 2. sayƒ±nƒ±n altƒ±nda, 1. sayƒ±nƒ±n √ºst√ºnde, VZ √ßizgisinin √ºst√ºnde
            const midPoint = (y1 + y2) / 2;
            y3 = Math.min(midPoint, vzY - 8); // VZ √ßizgisinin √ºst√ºne
          } else {
            // 3. sayƒ± 1. sayƒ±dan d√º≈ü√ºk ise
            // Hem 2. sayƒ±nƒ±n hem de 1. sayƒ±nƒ±n altƒ±nda
            y3 = Math.max(y1 + 20, height * 0.65);
          }
        }
        // 4. KURAL: 3. Sayƒ± alt panel √ßizgisinden yukarƒ±da bir sayƒ± ise
        else if (y2 === height * 0.75 && n3_val < n2_val) {
          if (n3_val <= n1_val) {
            // 3. sayƒ± 1. sayƒ±dan b√ºy√ºk deƒüilse
            // 2. sayƒ±nƒ±n √ºst√ºnde, 1. sayƒ±nƒ±n altƒ±nda, VZ √ßizgisinin altƒ±nda
            const midPoint = (y1 + y2) / 2;
            y3 = Math.max(midPoint, vzY + 8); // VZ √ßizgisinin altƒ±na
          } else {
            // 3. sayƒ± 1. sayƒ±dan yukarƒ±da ise
            // Hem 2. sayƒ±nƒ±n hem de 1. sayƒ±nƒ±n √ºst√ºnde
            y3 = Math.min(y1 - 20, height * 0.35);
          }
        }
        // Varsayƒ±lan durum - FOTOƒûRAFA G√ñRE DAHA A√áIK ARALIKLAR
        else {
          // 3. sayƒ± 1. ve 2. sayƒ±ya g√∂re konumlandƒ±r
          if (n3_val > n1_val && n3_val > n2_val) {
            y3 = Math.min(y1 - 20, y2 - 20); // Daha fazla bo≈üluk
            y3 = Math.max(y3, height * 0.2); // √úst sƒ±nƒ±r
          } else if (n3_val < n1_val && n3_val < n2_val) {
            y3 = Math.max(y1 + 20, y2 + 20); // Daha fazla bo≈üluk
            y3 = Math.min(y3, height * 0.8); // Alt sƒ±nƒ±r
          } else if (n3_val > n1_val && n3_val < n2_val) {
            y3 = y1 - 12; // 1. sayƒ±dan biraz √ºstte
          } else {
            y3 = y1 + 12; // 1. sayƒ±dan biraz altta
          }
        }
        
        // Y3 sƒ±nƒ±rlamalarƒ± - FOTOƒûRAFA G√ñRE AYARLANDI
        y3 = Math.max(y3, height * 0.2); // Minimum y√ºkseklik
        y3 = Math.min(y3, height * 0.8); // Maksimum y√ºkseklik
        
        // √áizgiyi √ßiz - DAHA KALIN VE BELƒ∞RGƒ∞N
        ctx.strokeStyle = isDark ? '#fff' : '#000';
        ctx.lineWidth = 2.0; // 1.5'ten 2.0'a artƒ±rƒ±ldƒ±
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.lineTo(x3, y3);
        ctx.stroke();
        
        // 1. VE 2. SAYI ARASINA VZ √áƒ∞ZGƒ∞Sƒ∞ - HER ZAMAN √áƒ∞Zƒ∞LECEK
        // FARK 1 KURALI YOK, SADECE KONUMA G√ñRE √áƒ∞Zƒ∞LECEK
        if (vzY !== null) {
          ctx.strokeStyle = '#FF9900';
          ctx.lineWidth = 2.5; // 2.0'dan 2.5'e artƒ±rƒ±ldƒ±
          ctx.beginPath();
          ctx.moveTo(x1 - 20, vzY); // Daha uzun √ßizgi
          ctx.lineTo(x2 + 20, vzY); // Daha uzun √ßizgi
          ctx.stroke();
        }
        // 2. VE 3. SAYI ARASINA VZ √áƒ∞Zƒ∞LMEYECEK - ƒ∞STEƒûE UYGUN
        
        // Noktalarƒ± √ßiz - DAHA B√úY√úK VE A√áIK ARALIKLAR
        const points = [{x: x1, y: y1}, {x: x2, y: y2}, {x: x3, y: y3}];
        points.forEach(function(p, i) {
          // Daire - DAHA B√úY√úK
          ctx.fillStyle = isDark ? '#000' : '#fff';
          ctx.beginPath();
          ctx.arc(p.x, p.y, 14, 0, Math.PI * 2); // 12'den 14'e b√ºy√ºt√ºld√º
          ctx.fill();
          ctx.strokeStyle = isDark ? '#fff' : '#000';
          ctx.lineWidth = 2.5; // 2'den 2.5'e artƒ±rƒ±ldƒ±
          ctx.stroke();
          
          // Sayƒ± - DAHA B√úY√úK VE BELƒ∞RGƒ∞N
          ctx.font = 'bold 16px sans-serif'; // 13px'ten 16px'e b√ºy√ºt√ºld√º
          ctx.fillStyle = colors[i] === 'blue' ? '#0066ff' : '#cc0000';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(String(numbers[i]), p.x, p.y);
        });
      });
    }
    
    // ========== AUTO TRADE FONKSƒ∞YONLARI ==========
    function toggleAutoTrade() {
      autoTradeEnabled = !autoTradeEnabled;
      const btn = document.getElementById('autoTradeBtn');
      if (autoTradeEnabled) {
        btn.classList.add('active');
        console.log('Auto Trade A√áIK');
      } else {
        btn.classList.remove('active');
        console.log('Auto Trade KAPALI');
      }
    }
    
    function executeAutoTrade() {
      if (!autoTradeEnabled || autoTradeInProgress || tradeActive || !currentUpDownSignal) return;
      if (!apiToken || !derivWS || derivWS.readyState !== WebSocket.OPEN) return;
      
      autoTradeInProgress = true;
      if (currentUpDownSignal === 'UP') {
        console.log('Auto Trade: CALL');
        placeTrade('CALL');
      } else if (currentUpDownSignal === 'DOWN') {
        console.log('Auto Trade: PUT');
        placeTrade('PUT');
      }
      setTimeout(function() {
        autoTradeInProgress = false;
      }, 6000);
    }
    
    // ========== TREND ANALƒ∞Z FONKSƒ∞YONLARI ==========
    function checkAndSignalTrend() {
      if (currentGraph !== 'XZ' || !startGlobalSpan || !trendStartGlobal || gridHistory.length < 6) {
        showTrendSignal(null);
        updateTrendPanelsData();
        drawTrendPanel('trendAngleCanvas1', trendPanel1Data);
        drawTrendPanel('trendAngleCanvas2', trendPanel2Data);
        return;
      }
      
      workerMessageQueue.push({
        type: 'analyzeTrend',
        data: { gridHistory, startGlobalSpan, xzTickCounter }
      });
      
      if (!workerBusy) {
        processWorkerQueue();
      }
      
      updateTrendPanelsData();
      drawTrendPanel('trendAngleCanvas1', trendPanel1Data);
      drawTrendPanel('trendAngleCanvas2', trendPanel2Data);
    }
    
    function showTrendSignal(direction) {
      const box = document.getElementById('trendBellBox');
      const label = document.getElementById('trendLabel');
      box.classList.remove('trend-up', 'trend-down');
      if (direction === 'UP') {
        box.classList.add('trend-up');
        label.textContent = 'Trend ‚Üë';
        if (lastTrendSignal !== 'UP') {
          playUpTrendSound();
          lastTrendSignal = 'UP';
        }
      } else if (direction === 'DOWN') {
        box.classList.add('trend-down');
        label.textContent = 'Trend ‚Üì';
        if (lastTrendSignal !== 'DOWN') {
          playDownTrendSound();
          lastTrendSignal = 'DOWN';
        }
      } else {
        label.textContent = 'Trend';
        lastTrendSignal = null;
      }
    }
    
    // ========== TEMA FONKSƒ∞YONLARI ==========
    function updateLogos() {
      const headerLogo = document.getElementById('headerLogo');
      const watermark = document.getElementById('chartWatermark');
      const isDark = !document.body.classList.contains('day-mode');
      if (isDark) {
        headerLogo.src = 'https://raw.githubusercontent.com/Samday68/Foto-raflar/refs/heads/main/D354DBAF-3EC7-4B5F-ABC1-8EF876797DAA.jpeg';
        watermark.src = 'https://raw.githubusercontent.com/Samday68/Foto-raflar/refs/heads/main/D354DBAF-3EC7-4B5F-ABC1-8EF876797DAA.jpeg';
      } else {
        headerLogo.src = 'https://raw.githubusercontent.com/Samday68/Foto-raflar/refs/heads/main/B3F65E6D-3FB0-45E3-A46A-7E788A46DEC7.jpeg';
        watermark.src = 'https://raw.githubusercontent.com/Samday68/Foto-raflar/refs/heads/main/B3F65E6D-3FB0-45E3-A46A-7E788A46DEC7.jpeg';
      }
    }
    
    function updateChartColors() {
      if (!chart) return;
      const isDark = !document.body.classList.contains('day-mode');
      chart.data.datasets[0].borderColor = isDark ? '#fff' : '#000';
      chart.data.datasets[0].backgroundColor = isDark ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.05)';
      chart.options.scales.y.grid.color = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
      chart.options.scales.x.grid.color = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
      chart.options.scales.y.ticks.color = isDark ? '#fff' : '#000';
      chart.options.scales.x.ticks.color = isDark ? '#fff' : '#000';
      chart.update();
    }
    
    function toggleTheme() {
      const body = document.body;
      const btn = document.getElementById('themeToggle');
      body.classList.toggle('day-mode');
      btn.innerText = body.classList.contains('day-mode') ? '‚òÄÔ∏è' : 'üåô';
      updateLogos();
      updateChartColors();
      renderXYArea();
      drawTrendPanel('trendAngleCanvas1', trendPanel1Data);
      drawTrendPanel('trendAngleCanvas2', trendPanel2Data);
      if (tradeActive) drawTradeChart();
    }
    
    // ========== TOKEN FONKSƒ∞YONLARI ==========
    function loadSavedToken() {
      const saved = localStorage.getItem('apiToken');
      if (saved) {
        document.getElementById('apiInput').value = saved;
        document.getElementById('saveCheckbox').checked = true;
      }
    }
    
    function toggleSaveToken() {
      const checkbox = document.getElementById('saveCheckbox');
      const input = document.getElementById('apiInput');
      if (checkbox.checked) {
        if (input.value.trim()) {
          localStorage.setItem('apiToken', input.value.trim());
        }
      } else {
        localStorage.removeItem('apiToken');
      }
    }
    
    // ========== KONTROL FONKSƒ∞YONLARI ==========
    function toggleStartStop() {
      isRunning = !isRunning;
      const btn = document.getElementById('startStopBtn');
      const text = document.getElementById('startStopText');
      if (isRunning) {
        btn.classList.remove('stopped');
        text.innerText = 'START';
        startWS();
      } else {
        btn.classList.add('stopped');
        text.innerText = 'STOP';
        if (ws) ws.close();
      }
    }
    
    function toggleGraph() {
      if (currentGraph === 'XZ') currentGraph = 'ZZ';
      else if (currentGraph === 'ZZ') currentGraph = 'Z.Z';
      else currentGraph = 'XZ';
      document.getElementById('graphToggle').innerText = currentGraph;
      if (chart) chart.update();
      renderXYArea();
      renderTwoRowGrid();
      renderStartOverlay();
    }
    
    function selectPair(pair) {
      currentPair = pair;
      document.querySelectorAll('.pair-btn').forEach(function(b) {
        b.classList.remove('active');
      });
      document.querySelector('.pair-btn[data-pair="' + pair + '"]').classList.add('active');
      if (ws) ws.close();
      prices = [];
      digits = [];
      decimalDigits = [];
      combinedDigits = [];
      wormLinesTop = [];
      numColors = [];
      document.getElementById('numbersTop').innerHTML = '';
      gridHistory = [];
      startCooldown = 0;
      startGlobalSpan = null;
      xzTickCounter = 0;
      currentTrendData = { direction: null, last3: [], colors: [], arrows: [] };
      trendPanel1Data = { numbers: [], colors: [] };
      trendPanel2Data = { numbers: [], colors: [] };
      lastTrendSignal = null;
      trendStartGlobal = null;
      showTrendSignal(null);
      renderTwoRowGrid();
      renderStartOverlay();
      renderXYArea();
      drawTrendPanel('trendAngleCanvas1', trendPanel1Data);
      drawTrendPanel('trendAngleCanvas2', trendPanel2Data);
      if (isRunning) startWS();
    }
    
    // ========== API FONKSƒ∞YONLARI ==========
    function connectAPI() {
      apiToken = document.getElementById('apiInput').value.trim();
      if (!apiToken) {
        alert('L√ºtfen ge√ßerli bir API token girin!');
        return;
      }
      derivWS = new WebSocket('wss://ws.binaryws.com/websockets/v3?app_id=1089');
      derivWS.onopen = function() {
        derivWS.send(JSON.stringify({ authorize: apiToken }));
      };
      derivWS.onmessage = function(msg) {
        const data = JSON.parse(msg.data);
        if (data.authorize) {
          alert('API Baƒülantƒ±sƒ± Ba≈üarƒ±lƒ±!');
          if (data.authorize.balance) {
            document.getElementById('balanceValue').innerText = '$ ' + parseFloat(data.authorize.balance).toFixed(2);
          }
          derivWS.send(JSON.stringify({ balance: 1, subscribe: 1 }));
        }
        if (data.balance) {
          document.getElementById('balanceValue').innerText = '$ ' + parseFloat(data.balance.balance).toFixed(2);
        }
        if (data.proposal_open_contract) {
          const contract = data.proposal_open_contract;
          if (tradeActive && contract.tick_stream) {
            const ticks = contract.tick_stream;
            if (tradeData.length === 0 && ticks.length > 0) {
              entrySpot = parseFloat(ticks[0].tick);
              barrier = parseFloat(contract.barrier || entrySpot);
              tradeData = [entrySpot];
              document.getElementById('tradeChart').style.display = 'block';
            }
            if (ticks.length > tradeData.length && tradeData.length < 6) {
              for (let i = tradeData.length; i < Math.min(ticks.length, 6); i++) {
                tradeData.push(parseFloat(ticks[i].tick));
              }
              drawTradeChart();
            }
          }
          if (contract.status === 'won' || contract.status === 'lost') {
            if (contract.exit_tick) {
              exitSpot = parseFloat(contract.exit_tick);
            }
            const profit = parseFloat(contract.profit || 0);
            document.getElementById('profitValue').innerText = (profit >= 0 ? '$ +' : '$ ') + profit.toFixed(2);
            drawTradeChart();
            tradeActive = false;
          }
        }
        if (data.error) {
          alert('API Hatasƒ±: ' + data.error.message);
        }
      };
    }
    
    function placeTrade(type) {
      if (!apiToken || !derivWS || derivWS.readyState !== WebSocket.OPEN) {
        alert('√ñnce API baƒülantƒ±sƒ± yapƒ±n!');
        return;
      }
      const stakeInput = document.getElementById('stakeInput');
      let stake = parseFloat(stakeInput.value);
      if (isNaN(stake) || stake < 0.35) {
        alert('Minimum stake 0.35 USD olmalƒ±!');
        stakeInput.value = '1';
        return;
      }
      const proposal = {
        proposal: 1,
        amount: stake,
        basis: 'stake',
        contract_type: type,
        currency: 'USD',
        duration: 5,
        duration_unit: 't',
        symbol: currentPair
      };
      derivWS.send(JSON.stringify(proposal));
      const handleProposal = function(msg) {
        const data = JSON.parse(msg.data);
        if (data.proposal) {
          const proposalId = data.proposal.id;
          derivWS.send(JSON.stringify({ buy: proposalId, price: stake }));
        }
        if (data.buy) {
          contractId = data.buy.contract_id;
          tradeActive = true;
          tradeType = type;
          entrySpot = 0;
          exitSpot = 0;
          barrier = 0;
          tradeData = [];
          derivWS.send(JSON.stringify({ proposal_open_contract: 1, contract_id: contractId, subscribe: 1 }));
          derivWS.removeEventListener('message', handleProposal);
        }
        if (data.error) {
          alert('Trade Hatasƒ±: ' + data.error.message);
          derivWS.removeEventListener('message', handleProposal);
        }
      };
      derivWS.addEventListener('message', handleProposal);
    }
    
    // ========== TRADE CHART ==========
    function drawTradeChart() {
      requestAnimationFrame(() => {
        const canvas = document.getElementById('tradeCanvas');
        if (!canvas || tradeData.length === 0) return;
        
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        const ctx = canvas.getContext('2d');
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, rect.width, rect.height);
        
        const isDark = !document.body.classList.contains('day-mode');
        const width = rect.width;
        const height = rect.height;
        const padding = 12;
        const allValues = tradeData.concat([barrier]);
        const minVal = Math.min.apply(null, allValues);
        const maxVal = Math.max.apply(null, allValues);
        const range = maxVal - minVal || 0.001;
        const marginPercent = 0.1;
        const adjustedMin = minVal - (range * marginPercent);
        const adjustedMax = maxVal + (range * marginPercent);
        const adjustedRange = adjustedMax - adjustedMin;
        
        function getY(val) {
          return height - padding - ((val - adjustedMin) / adjustedRange) * (height - 2 * padding);
        }
        
        if (tradeData.length > 0) {
          ctx.strokeStyle = '#FF8C00';
          ctx.lineWidth = 1.5;
          ctx.setLineDash([4, 2]);
          ctx.beginPath();
          ctx.moveTo(padding, padding);
          ctx.lineTo(padding, height - padding);
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.font = '7px sans-serif';
          ctx.fillStyle = '#FF8C00';
          ctx.textAlign = 'center';
          ctx.fillText('Entry', padding, padding - 2);
        }
        
        if (barrier > 0) {
          const barrierY = getY(barrier);
          ctx.strokeStyle = isDark ? '#fff' : '#000';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(padding, barrierY);
          ctx.lineTo(width - padding, barrierY);
          ctx.stroke();
          ctx.font = '7px sans-serif';
          ctx.fillStyle = isDark ? '#fff' : '#000';
          ctx.textAlign = 'left';
          ctx.fillText('Barrier', padding + 2, barrierY - 3);
        }
        
        if (tradeData.length > 0) {
          const stepX = (width - 2 * padding) / 5;
          ctx.strokeStyle = '#6B8CAE';
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          tradeData.forEach(function(val, i) {
            const x = padding + (i * stepX);
            const y = getY(val);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          });
          ctx.stroke();
          
          tradeData.forEach(function(val, i) {
            if (i < 1) return;
            const x = padding + (i * stepX);
            const y = getY(val);
            ctx.fillStyle = '#6B8CAE';
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fill();
          });
          
          if (tradeData.length === 6) {
            const exitX = padding + (5 * stepX);
            ctx.strokeStyle = '#FF8C00';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([4, 2]);
            ctx.beginPath();
            ctx.moveTo(exitX, padding);
            ctx.lineTo(exitX, height - padding);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.font = '7px sans-serif';
            ctx.fillStyle = '#FF8C00';
            ctx.textAlign = 'center';
            ctx.fillText('Exit', exitX, padding - 2);
          }
        }
        
        if (tradeData.length === 6 && exitSpot > 0) {
          const won = (tradeType === 'CALL' && exitSpot > barrier) || (tradeType === 'PUT' && exitSpot < barrier);
          ctx.fillStyle = won ? 'rgba(76, 175, 80, 0.15)' : 'rgba(244, 67, 54, 0.15)';
          ctx.fillRect(0, 0, width, height);
        }
      });
    }
    
    // ========== WORM FONKSƒ∞YONLARI ==========
    function updateWorm() {
      if (prices.length < 20) return;
      const last20 = prices.slice(-20);
      const max = Math.max.apply(null, last20.slice(0, -1));
      const min = Math.min.apply(null, last20.slice(0, -1));
      const last = last20[last20.length - 1];
      let color = 'lightgreen';
      if (last > max) color = 'blue';
      else if (last < min) color = 'red';
      wormLinesTop.push(color);
      if (wormLinesTop.length > 20) wormLinesTop.shift();
    }
    
    function renderWormLines(containerId, wormArray) {
      requestAnimationFrame(() => {
        const c = document.getElementById(containerId);
        c.querySelectorAll('.worm-line').forEach(function(e) { e.remove(); });
        const boxes = c.querySelectorAll('.num-box');
        boxes.forEach(function(box, idx) {
          if (!wormArray[idx]) return;
          const line = document.createElement('div');
          line.className = 'worm-line';
          line.style.width = box.offsetWidth + 'px';
          line.style.left = box.offsetLeft + 'px';
          line.style.top = (box.offsetTop + box.offsetHeight + 0.2) + 'px';
          line.style.borderTopColor = wormArray[idx];
          c.appendChild(line);
        });
      });
    }
    
    // ========== XY AREA ==========
    function renderXYArea() {
      requestAnimationFrame(() => {
        const canvas = document.getElementById('xyCanvas');
        if (!canvas) return;
        
        const box = document.getElementById('xyBox');
        const rect = box.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        const ctx = canvas.getContext('2d');
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, rect.width, rect.height);
        
        if (currentGraph !== 'XZ') return;
        const vis = Math.min(11, decimalDigits.length);
        if (vis < 2) return;
        
        const decSlice = decimalDigits.slice(-vis);
        const colorSlice = numColors.slice(-vis);
        const isDark = !document.body.classList.contains('day-mode');
        
        const values = decSlice.map(function(d) {
          let v = parseInt((d || '0'), 10);
          if (isNaN(v)) v = 0;
          if (v === 0) v = 10;
          return v;
        });
        
        const width = rect.width;
        const height = rect.height;
        const marginX = 32;
        const marginTop = 14;
        const marginBottom = 24;
        const stepX = (width - 2 * marginX) / (vis - 1);
        const xs = [];
        for (let i = 0; i < vis; i++) xs.push(marginX + i * stepX);
        
        const baseY = height / 2;
        const maxAmp = (height / 2) - marginTop - marginBottom;
        const unitY = maxAmp / 10;
        
        function pointY(idx) {
          const v = values[idx];
          const col = colorSlice[idx];
          if (col === 'blue') return baseY - v * unitY;
          if (col === 'red') return baseY + v * unitY;
          return baseY;
        }
        
        // Draw horizontal line
        ctx.strokeStyle = isDark ? '#fff' : '#000';
        ctx.lineWidth = 2.0;
        ctx.beginPath();
        ctx.moveTo(marginX - 10, baseY);
        ctx.lineTo(width - marginX + 10, baseY);
        ctx.stroke();
        
        // Draw vertical split line
        const splitIndex = vis - 6;
        const splitX = xs[splitIndex] - stepX * 0.15;
        ctx.lineWidth = 2.0;
        
        ctx.strokeStyle = '#0b57d0';
        ctx.beginPath();
        ctx.moveTo(splitX, marginTop - 6);
        ctx.lineTo(splitX, baseY);
        ctx.stroke();
        
        ctx.strokeStyle = '#d93025';
        ctx.beginPath();
        ctx.moveTo(splitX, baseY);
        ctx.lineTo(splitX, height - marginBottom + 12);
        ctx.stroke();
        
        // Draw value labels
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        for (let v = 1; v <= 10; v++) {
          const yUp = baseY - v * unitY;
          const yDn = baseY + v * unitY;
          if (yUp > marginTop - 4) {
            ctx.fillStyle = '#0b57d0';
            ctx.fillText(String(v), marginX - 16, yUp);
          }
          if (yDn < height - marginBottom + 6) {
            ctx.fillStyle = '#d93025';
            ctx.fillText(String(v), marginX - 16, yDn);
          }
        }
        
        // Draw main line
        ctx.strokeStyle = '#777';
        ctx.lineWidth = 2.0;
        const startIdx = vis - 6;
        ctx.beginPath();
        for (let i = startIdx; i < vis; i++) {
          const x = xs[i];
          const y = pointY(i);
          if (i === startIdx) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
        
        // Draw points with values
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = 'bold 15px sans-serif';
        for (let i = 0; i < vis; i++) {
          const x = xs[i];
          const y = pointY(i);
          const col = colorSlice[i];
          ctx.fillStyle = (col === 'blue' ? '#0b57d0' : (col === 'red' ? '#d93025' : '#666'));
          const shown = (values[i] === 10 ? 0 : values[i]);
          ctx.fillText(String(shown), x, y);
        }
        
        // Draw VZ lines
        ctx.strokeStyle = isDark ? '#40E0D0' : '#000';
        ctx.lineWidth = 2.3;
        function drawVZ(i, j) {
          const v1 = values[i], v2 = values[j];
          const c1 = colorSlice[i], c2 = colorSlice[j];
          if (c1 !== c2) return;
          if (c1 !== 'blue' && c1 !== 'red') return;
          if (Math.abs(v1 - v2) !== 1) return;
          const x1 = xs[i], x2 = xs[j];
          const y1 = pointY(i), y2 = pointY(j);
          const yMid = (y1 + y2) / 2;
          const extra = 10;
          ctx.beginPath();
          ctx.moveTo(x1 - extra, yMid);
          ctx.lineTo(x2 + extra, yMid);
          ctx.stroke();
        }
        
        for (let i = 0; i < vis - 1; i++) drawVZ(i, i + 1);
        const winStart = Math.max(0, vis - 6);
        for (let i = winStart; i < vis; i++) {
          for (let j = i + 2; j < vis; j++) drawVZ(i, j);
        }
        
        // Draw special circles for pattern matches
        const lastLocal = vis - 1;
        const lastVal = values[lastLocal];
        const lastCol = colorSlice[lastLocal];
        const pairs = [];
        for (let k = 1; k <= 5; k++) {
          const idx = lastLocal - k;
          if (idx < 0) break;
          const prevCol = colorSlice[idx];
          if (Math.abs(lastVal - values[idx]) === 1 && lastCol !== prevCol && lastCol !== '#666' && prevCol !== '#666') {
            pairs.push(idx);
          }
        }
        
        if (pairs.length > 0) {
          ctx.strokeStyle = isDark ? '#fff' : '#000';
          ctx.lineWidth = 2;
          const radius = 10;
          const xL = xs[lastLocal], yL = pointY(lastLocal);
          ctx.beginPath();
          ctx.arc(xL, yL, radius, 0, Math.PI * 2);
          ctx.stroke();
          
          pairs.forEach(function(idx) {
            const x = xs[idx], y = pointY(idx);
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.stroke();
          });
          
          ctx.font = 'bold 16px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          const shownLast = (values[lastLocal] === 10 ? 0 : values[lastLocal]);
          ctx.fillStyle = (lastCol === 'blue' ? '#0b57d0' : (lastCol === 'red' ? '#d93025' : '#666'));
          ctx.fillText(String(shownLast), xL, yL);
          
          pairs.forEach(function(idx) {
            const x = xs[idx], y = pointY(idx);
            const col = colorSlice[idx];
            const shown = (values[idx] === 10 ? 0 : values[idx]);
            ctx.fillStyle = (col === 'blue' ? '#0b57d0' : (col === 'red' ? '#d93025' : '#666'));
            ctx.fillText(String(shown), x, y);
          });
        }
      });
    }
    
    // ========== GRID FONKSƒ∞YONLARI ==========
    function isEven(n) {
      return (n % 2) === 0;
    }
    
    function decideRow(prev, currV, effColor) {
      if (!prev) return (effColor === 'blue') ? 'top' : 'bottom';
      if (currV === prev.v && effColor === prev.effColor) return prev.row;
      if (prev.effColor !== effColor) return (effColor === 'blue') ? 'top' : 'bottom';
      if (effColor === 'blue') return (currV > prev.v) ? 'top' : 'bottom';
      else return (currV < prev.v) ? 'top' : 'bottom';
    }
    
    function updateGridFromLast11() {
      if (currentGraph !== 'XZ') {
        gridHistory = [];
        startGlobalSpan = null;
        startCooldown = 0;
        renderTwoRowGrid();
        renderStartOverlay();
        updateTrendPanelsData();
        drawTrendPanel('trendAngleCanvas1', trendPanel1Data);
        drawTrendPanel('trendAngleCanvas2', trendPanel2Data);
        return;
      }
      
      const vis = Math.min(11, decimalDigits.length);
      if (vis <= 0) {
        gridHistory = [];
        renderTwoRowGrid();
        renderStartOverlay();
        updateTrendPanelsData();
        drawTrendPanel('trendAngleCanvas1', trendPanel1Data);
        drawTrendPanel('trendAngleCanvas2', trendPanel2Data);
        return;
      }
      
      const decSlice = decimalDigits.slice(-vis).map(function(x) {
        let v = parseInt((x || '0'), 10);
        if (isNaN(v)) v = 0;
        return v;
      });
      
      const colSlice = numColors.slice(-vis);
      const newHist = [];
      
      for (let i = 0; i < vis; i++) {
        const raw = colSlice[i] || '#666';
        const rawColor = (raw === 'blue' || raw === 'red') ? raw : '#666';
        const prev = newHist.length ? newHist[newHist.length - 1] : null;
        let effColor = rawColor;
        if (effColor !== 'blue' && effColor !== 'red') {
          effColor = prev ? prev.effColor : 'blue';
        }
        const row = decideRow(prev, decSlice[i], effColor);
        newHist.push({ v: decSlice[i], rawColor: rawColor, effColor: effColor, row: row });
      }
      
      gridHistory = newHist;
      if (startCooldown > 0) startCooldown--;
      detectStartGlobal();
      renderTwoRowGrid();
      renderStartOverlay();
      updateTrendPanelsData();
      drawTrendPanel('trendAngleCanvas1', trendPanel1Data);
      drawTrendPanel('trendAngleCanvas2', trendPanel2Data);
      checkAndSignalTrend();
      setTimeout(renderStartOverlay, 0);
    }
    
    function detectStartGlobal() {
      if (currentGraph !== 'XZ') return;
      if (startCooldown > 0) return;
      if (gridHistory.length < 3) return;
      
      const vis = gridHistory.length;
      const firstGlobal = xzTickCounter - vis;
      const n = vis;
      const a = gridHistory[n - 3].v;
      const b = gridHistory[n - 2].v;
      const c = gridHistory[n - 1].v;
      const cond1 = isEven(a) && isEven(b) && !isEven(c);
      const cond2 = !isEven(a) && !isEven(b) && isEven(c);
      
      if (cond1 || cond2) {
        startGlobalSpan = { from: firstGlobal + (n - 3), to: firstGlobal + (n - 1) };
        startCooldown = 6;
        trendStartGlobal = firstGlobal + (n - 1);
        lastTrendSignal = null;
        showTrendSignal(null);
        currentTrendData = { direction: null, last3: [], colors: [], arrows: [] };
      }
    }
    
    function renderTwoRowGrid() {
      requestAnimationFrame(() => {
        const topRow = document.getElementById('gridTopRow');
        const botRow = document.getElementById('gridBottomRow');
        const dividerLine = document.getElementById('gridDividerLine');
        if (!topRow || !botRow || !dividerLine) return;
        
        topRow.innerHTML = '';
        botRow.innerHTML = '';
        const vis = gridHistory.length;
        
        if (vis === 0) {
          dividerLine.style.width = '0px';
          return;
        }
        
        const topFragment = document.createDocumentFragment();
        const botFragment = document.createDocumentFragment();
        
        for (let i = 0; i < vis; i++) {
          const item = gridHistory[i];
          const cellTop = document.createElement('div');
          cellTop.className = 'grid-cell grid-top';
          const cellBot = document.createElement('div');
          cellBot.className = 'grid-cell grid-bottom';
          
          const showColor = (item.rawColor === 'blue' || item.rawColor === 'red') ? item.rawColor : item.effColor;
          
          if (item.row === 'top') {
            cellTop.style.color = showColor;
            cellTop.textContent = String(item.v);
            cellBot.textContent = '';
          } else {
            cellBot.style.color = showColor;
            cellBot.textContent = String(item.v);
            cellTop.textContent = '';
          }
          
          topFragment.appendChild(cellTop);
          botFragment.appendChild(cellBot);
        }
        
        topRow.appendChild(topFragment);
        botRow.appendChild(botFragment);
        
        const firstCell = topRow.querySelector('.grid-cell');
        const cellW = firstCell ? firstCell.getBoundingClientRect().width : 36;
        dividerLine.style.width = (vis * cellW) + 'px';
      });
    }
    
    function renderStartOverlay() {
      requestAnimationFrame(() => {
        document.querySelectorAll('.start-box').forEach(function(e) { e.remove(); });
        if (!startGlobalSpan) return;
        if (currentGraph !== 'XZ') return;
        
        const wrap = document.getElementById('gridWrap');
        const topRow = document.getElementById('gridTopRow');
        const botRow = document.getElementById('gridBottomRow');
        if (!wrap || !topRow || !botRow) return;
        
        const topCells = topRow.querySelectorAll('.grid-cell');
        const botCells = botRow.querySelectorAll('.grid-cell');
        const vis = topCells.length;
        if (vis === 0) return;
        
        const firstGlobal = xzTickCounter - vis;
        const fromLocal = startGlobalSpan.from - firstGlobal;
        const toLocal = startGlobalSpan.to - firstGlobal;
        
        if (fromLocal < 0 || toLocal >= vis) return;
        
        const c1 = topCells[fromLocal];
        const c2 = topCells[toLocal];
        const b1 = botCells[fromLocal];
        const b2 = botCells[toLocal];
        if (!c1 || !c2 || !b1 || !b2) return;
        
        const rWrap = wrap.getBoundingClientRect();
        const r1 = c1.getBoundingClientRect();
        const r2 = c2.getBoundingClientRect();
        const rb1 = b1.getBoundingClientRect();
        const rb2 = b2.getBoundingClientRect();
        
        const left = Math.min(r1.left, rb1.left) - rWrap.left;
        const right = Math.max(r2.right, rb2.right) - rWrap.left;
        const top = Math.min(r1.top, rb1.top) - rWrap.top;
        const bottom = Math.max(r2.bottom, rb2.bottom) - rWrap.top;
        
        const box = document.createElement('div');
        box.className = 'start-box';
        box.style.left = (left - 2) + 'px';
        box.style.top = (top - 2) + 'px';
        box.style.width = (right - left + 4) + 'px';
        box.style.height = (bottom - top + 4) + 'px';
        
        const label = document.createElement('div');
        label.className = 'start-label';
        label.textContent = 'start';
        box.appendChild(label);
        
        wrap.appendChild(box);
      });
    }
    
    // ========== WEBSOCKET ==========
    function startWS() {
      ws = new WebSocket('wss://ws.binaryws.com/websockets/v3?app_id=1089');
      ws.onopen = function() {
        ws.send(JSON.stringify({ ticks_history: currentPair, end: "latest", count: 20, subscribe: 1 }));
      };
      ws.onmessage = function(msg) {
        const d = JSON.parse(msg.data);
        
        if (d.history) {
          d.history.prices.forEach(function(p) {
            const priceStr = String(p);
            const price = parseFloat(p);
            prices.push(price);
            const parts = priceStr.split('.');
            const intPart = parts[0];
            let decPart = parts[1] || '0';
            if (decPart.length === 1) decPart = decPart + '0';
            const lastTwo = intPart.slice(-2);
            digits.push(lastTwo);
            const lastDec = decPart.charAt(decPart.length - 1) || '0';
            decimalDigits.push(lastDec);
            xzTickCounter++;
            const lastInt = intPart.slice(-1);
            const firstDec = decPart.charAt(0) || '0';
            combinedDigits.push(lastInt + ',' + firstDec);
            updateWorm();
          });
        }
        
        if (d.tick) {
          const priceStr = d.tick.quote.toString();
          const price = parseFloat(d.tick.quote);
          prices.push(price);
          if (prices.length > 20) prices.shift();
          
          const parts = priceStr.split('.');
          const intPart = parts[0];
          let decPart = parts[1] || '0';
          if (decPart.length === 1) decPart = decPart + '0';
          
          const lastTwo = intPart.slice(-2);
          digits.push(lastTwo);
          if (digits.length > 20) digits.shift();
          
          const lastDec = decPart.charAt(decPart.length - 1) || '0';
          decimalDigits.push(lastDec);
          if (decimalDigits.length > 20) decimalDigits.shift();
          
          xzTickCounter++;
          const lastInt = intPart.slice(-1);
          const firstDec = decPart.charAt(0) || '0';
          combinedDigits.push(lastInt + ',' + firstDec);
          if (combinedDigits.length > 20) combinedDigits.shift();
          
          updateWorm();
          
          const priceEl = document.getElementById('price');
          let displayPrice = intPart;
          if (decPart && decPart !== '00') {
            displayPrice = intPart + ',' + decPart;
          } else {
            displayPrice = intPart + ',00';
          }
          priceEl.innerText = displayPrice;
          
          if (prices.length > 1) {
            const prev = prices[prices.length - 2];
            if (price > prev) priceEl.style.background = 'blue';
            else if (price < prev) priceEl.style.background = 'red';
            else priceEl.style.background = '#0b57d0';
          }
        }
        
        // Update numbers row
        const row = document.getElementById('numbersTop');
        row.innerHTML = '';
        numColors = [];
        const activeArr = (currentGraph === 'XZ' ? decimalDigits : (currentGraph === 'ZZ' ? digits : combinedDigits));
        const sliceArr = activeArr.slice(-11);
        
        const fragment = document.createDocumentFragment();
        
        for (let i = 0; i < sliceArr.length; i++) {
          const globalIndex = activeArr.length - 11 + i;
          const up = globalIndex > 0 && prices[globalIndex] > prices[globalIndex - 1];
          const down = globalIndex > 0 && prices[globalIndex] < prices[globalIndex - 1];
          const color = up ? 'blue' : (down ? 'red' : '#666');
          numColors.push(color);
          
          const box = document.createElement('div');
          box.className = 'num-box';
          box.style.background = color;
          box.innerText = (currentGraph === 'Z.Z') ? (sliceArr[i] || '').replace(',', '.') : (sliceArr[i] || '0');
          fragment.appendChild(box);
        }
        
        row.appendChild(fragment);
        
        // Update chart
        const last11 = prices.slice(-11);
        if (chart) {
          chart.data.datasets[0].data = last11;
          chart.data.datasets[0].pointBackgroundColor = last11.map(function(p, i) {
            if (i === 0) return 'gray';
            if (p > last11[i - 1]) return 'blue';
            if (p < last11[i - 1]) return 'red';
            return 'gray';
          });
          chart.data.datasets[0].pointBorderColor = Array(last11.length).fill('transparent');
          chart.data.labels = Array.from({ length: last11.length }, function(_, i) { return (i + 1).toString(); });
          chart.update();
        }
        
        updateGridFromLast11();
        
        setTimeout(function() {
          renderWormLines('numbersTop', wormLinesTop.slice(-11));
          renderXYArea();
          renderStartOverlay();
        }, 40);
      };
    }
    
    // ========== ZAMAN ==========
    function updateTime() {
      const now = new Date();
      const hh = now.getUTCHours().toString().padStart(2, '0');
      const mm = now.getUTCMinutes().toString().padStart(2, '0');
      const ss = now.getUTCSeconds().toString().padStart(2, '0');
      document.getElementById('time').innerText = 'GMT ' + hh + ':' + mm + ':' + ss;
    }
    
    // ========== CHART OLU≈ûTURMA ==========
    function initChart() {
      const ctx = document.getElementById('chart').getContext('2d');
      chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: Array.from({ length: 11 }, function(_, i) { return (i + 1).toString(); }),
          datasets: [{
            data: Array(11).fill(null),
            borderColor: '#fff',
            borderWidth: 1.5,
            backgroundColor: 'rgba(255,255,255,0.05)',
            pointBackgroundColor: Array(11).fill('#fff'),
            pointRadius: 2,
            pointHoverRadius: 3
          }]
        },
        options: {
          plugins: { legend: { display: false }, tooltip: { enabled: false } },
          scales: {
            y: { 
              beginAtZero: false, 
              grid: { color: 'rgba(255,255,255,0.1)' }, 
              ticks: { color: '#fff' } 
            },
            x: { 
              grid: { color: 'rgba(255,255,255,0.1)' }, 
              ticks: { color: '#fff' } 
            }
          },
          animation: false,
          maintainAspectRatio: false
        },
        plugins: [{
          afterDatasetsDraw: function(chartInstance) {
            const ctx = chartInstance.ctx;
            const meta = chartInstance.getDatasetMeta(0);
            const isDark = !document.body.classList.contains('day-mode');
            
            const decs = decimalDigits.slice(-11);
            const colors = numColors.slice(-11);
            const values = decs.map(function(d) {
              let v = parseInt((d || '0'), 10);
              if (isNaN(v)) v = 0;
              return v;
            });
            
            for (let i = 0; i < values.length - 1; i++) {
              const v1 = values[i];
              const v2 = values[i + 1];
              const c1 = colors[i];
              const c2 = colors[i + 1];
              
              if (Math.abs(v1 - v2) !== 1) continue;
              
              const pt1 = meta.data[i];
              const pt2 = meta.data[i + 1];
              if (!pt1 || !pt2) continue;
              
              const midX = (pt1.x + pt2.x) / 2;
              const midY = (pt1.y + pt2.y) / 2;
              
              ctx.strokeStyle = isDark ? '#40E0D0' : '#000';
              ctx.lineWidth = 0.9;
              ctx.beginPath();
              ctx.moveTo(midX - 18, midY);
              ctx.lineTo(midX + 18, midY);
              ctx.stroke();
              
              ctx.font = 'bold 9px sans-serif';
              ctx.fillStyle = isDark ? '#40E0D0' : '#000';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText('VZ', midX, midY - 10);
              
              let arrowColor = '';
              if (c1 === c2) {
                if (c1 === 'blue') arrowColor = v2 > v1 ? 'blue' : 'red';
                else if (c1 === 'red') arrowColor = v2 < v1 ? 'blue' : 'red';
              } else {
                if (c1 === 'blue' && c2 === 'red') arrowColor = v1 < v2 ? 'red' : 'blue';
                else if (c1 === 'red' && c2 === 'blue') arrowColor = v2 > v1 ? 'blue' : 'red';
              }
              
              if (!arrowColor) continue;
              
              const arrowX = midX + 35;
              const arrowSize = 7;
              const stemLength = 16;
              
              ctx.strokeStyle = arrowColor;
              ctx.fillStyle = arrowColor;
              ctx.lineWidth = 2;
              
              if (arrowColor === 'blue') {
                ctx.beginPath();
                ctx.moveTo(arrowX - stemLength * 0.707, midY + stemLength * 0.707);
                ctx.lineTo(arrowX, midY);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(arrowX, midY);
                ctx.lineTo(arrowX - arrowSize, midY);
                ctx.lineTo(arrowX, midY + arrowSize);
                ctx.closePath();
                ctx.fill();
              } else {
                ctx.beginPath();
                ctx.moveTo(arrowX - stemLength * 0.707, midY - stemLength * 0.707);
                ctx.lineTo(arrowX, midY);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(arrowX, midY);
                ctx.lineTo(arrowX - arrowSize, midY);
                ctx.lineTo(arrowX, midY - arrowSize);
                ctx.closePath();
                ctx.fill();
              }
            }
            
            ctx.font = '900 15px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            
            const digs = digits.slice(-11);
            const combs = combinedDigits.slice(-11);
            const worms = wormLinesTop.slice(-11);
            
            meta.data.forEach(function(pt, i) {
              let t = '';
              if (currentGraph === 'XZ') t = decs[i] || '';
              else if (currentGraph === 'ZZ') t = digs[i] || '';
              else t = (combs[i] || '').replace(',', '.');
              
              if (pt && pt.x !== undefined) {
                let fillColor = colors[i] || '#000';
                if (fillColor === 'blue') fillColor = '#6A9FFF';
                ctx.fillStyle = fillColor;
                ctx.fillText(t, pt.x, pt.y - 2);
                
                const wormColor = worms[i];
                if (wormColor === 'blue' || wormColor === 'red') {
                  ctx.strokeStyle = wormColor;
                  ctx.lineWidth = 2;
                  ctx.beginPath();
                  ctx.moveTo(pt.x - 5, pt.y - 2);
                  ctx.lineTo(pt.x + 5, pt.y - 2);
                  ctx.stroke();
                }
              }
            });
            
            const last = meta.data[meta.data.length - 1];
            if (last && last.x !== undefined) {
              ctx.strokeStyle = isDark ? '#40E0D0' : '#000';
              ctx.lineWidth = 0.5;
              ctx.beginPath();
              ctx.moveTo(chartInstance.scales.x.left, last.y);
              ctx.lineTo(last.x, last.y);
              ctx.stroke();
            }
          }
        }]
      });
    }
    
    // ========== BA≈ûLATMA ==========
    document.addEventListener('DOMContentLoaded', function() {
      // Hide loading indicator
      setTimeout(() => {
        document.getElementById('loadingIndicator').style.opacity = '0';
        setTimeout(() => {
          document.getElementById('loadingIndicator').style.display = 'none';
        }, 300);
      }, 1000);
      
      // Initialize web worker
      initWebWorker();
      
      // Chart'ƒ± ba≈ülat
      initChart();
      
      // Enable hardware acceleration for performance
      document.querySelectorAll('.grid-cell, .num-box, #chartContainer, #xyBox').forEach(el => {
        el.classList.add('performance-mode', 'hw-accelerate');
      });
      
      // Event listener'larƒ± ekle
      document.getElementById('themeToggle').addEventListener('click', toggleTheme);
      document.getElementById('graphToggle').addEventListener('click', toggleGraph);
      document.getElementById('startStopBtn').addEventListener('click', toggleStartStop);
      document.getElementById('connectBtn').addEventListener('click', connectAPI);
      document.getElementById('saveCheckbox').addEventListener('change', toggleSaveToken);
      document.getElementById('autoTradeBtn').addEventListener('click', toggleAutoTrade);
      document.getElementById('callBtn').addEventListener('click', function() { placeTrade('CALL'); });
      document.getElementById('putBtn').addEventListener('click', function() { placeTrade('PUT'); });
      
      // Pair butonlarƒ±
      document.querySelectorAll('.pair-btn').forEach(function(btn) {
        btn.addEventListener('click', function() {
          selectPair(this.getAttribute('data-pair'));
        });
      });
      
      // Zaman g√ºncelleme
      setInterval(updateTime, 1000);
      updateTime();
      
      // WebSocket ba≈ülat
      startWS();
      
      // Token y√ºkle
      loadSavedToken();
      
      // Logolarƒ± g√ºncelle
      updateLogos();
      
      // Audio init
      document.body.addEventListener('click', function initAudioOnce() {
        initAudio();
        if (audioContext && audioContext.state === 'suspended') {
          audioContext.resume();
        }
      }, { once: true });
      
      document.body.addEventListener('touchstart', function() {
        if (audioContext && audioContext.state === 'suspended') {
          audioContext.resume();
        }
      }, { passive: true });
      
      // Resize handler with debouncing
      let resizeTimeout;
      window.addEventListener('resize', function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function() {
          renderXYArea();
          renderStartOverlay();
          renderTwoRowGrid();
          drawTrendPanel('trendAngleCanvas1', trendPanel1Data);
          drawTrendPanel('trendAngleCanvas2', trendPanel2Data);
        }, 100);
      });
      
      // Service Worker Registration
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', function() {
          navigator.serviceWorker.register('/service-worker.js').then(function(registration) {
            console.log('ServiceWorker registration successful with scope: ', registration.scope);
          }, function(err) {
            console.log('ServiceWorker registration failed: ', err);
          });
        });
      }
    });
  </script>
</body>
</html>
